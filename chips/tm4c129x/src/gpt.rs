use kernel::hil;
use core::cell::Cell;
// Automatically generated by tm4c129x_codegen.py
use kernel::common::VolatileCell;
use sysctl;

struct Registers {
    cfg: VolatileCell<u32>,
    tamr: VolatileCell<u32>,
    tbmr: VolatileCell<u32>,
    ctl: VolatileCell<u32>,
    sync: VolatileCell<u32>,
    _reserved0: [u32; 1],
    imr: VolatileCell<u32>,
    ris: VolatileCell<u32>,
    mis: VolatileCell<u32>,
    icr: VolatileCell<u32>,
    tailr: VolatileCell<u32>,
    tbilr: VolatileCell<u32>,
    tamatchr: VolatileCell<u32>,
    tbmatchr: VolatileCell<u32>,
    tapr: VolatileCell<u32>,
    tbpr: VolatileCell<u32>,
    tapmr: VolatileCell<u32>,
    tbpmr: VolatileCell<u32>,
    tar: VolatileCell<u32>,
    tbr: VolatileCell<u32>,
    tav: VolatileCell<u32>,
    tbv: VolatileCell<u32>,
    rtcpd: VolatileCell<u32>,
    taps: VolatileCell<u32>,
    tbps: VolatileCell<u32>,
    _reserved1: [u32; 2],
    dmaev: VolatileCell<u32>,
    adcev: VolatileCell<u32>,
    _reserved2: [u32; 979],
    pp: VolatileCell<u32>,
    _reserved3: [u32; 1],
    cc: VolatileCell<u32>,
}

const TIMER0_BASE: usize = 0x40030000;

pub static mut TIMER0: AlarmTimer = AlarmTimer::new(TIMER0_BASE,
                                                    sysctl::Clock::TIMER(sysctl::RCGCTIMER::TIMER0));

pub struct AlarmTimer {
    registers: *mut Registers,
    clock: sysctl::Clock,
    client: Cell<Option<&'static hil::time::Client>>,
}

impl AlarmTimer {
    const fn new(base_addr: usize, clock: sysctl::Clock) -> AlarmTimer {
        AlarmTimer {
            registers: base_addr as *mut Registers,
            clock: clock,
            client: Cell::new(None),
        }
    }

    fn disable_interrupts(&self) {
        let regs: &Registers = unsafe { &*self.registers };
        regs.imr.set(regs.imr.get() & !(1 << 4)); // clear CC1IE
    }

    pub fn handle_interrupt(&self) {
        let regs: &Registers = unsafe { &*self.registers };
        // check if caused by CC1IF
        if regs.mis.get() & (1 << 4) != 0 {
            self.disable_interrupts();
            regs.icr.set(regs.icr.get() | (1 << 4)); // clear CC1IF
            self.client.get().map(|cb| { cb.fired(); });
        }
    }
}

impl hil::Controller for AlarmTimer {
    type Config = &'static hil::time::Client;

    fn configure(&self, client: &'static hil::time::Client) {
        let regs: &Registers = unsafe { &*self.registers };
        self.client.set(Some(client));
        unsafe {
            sysctl::enable_clock(self.clock);
        }

        regs.ctl.set(0);
        regs.cfg.set(0x4);
        regs.tamr.set(regs.tamr.get() | (0x10) | 0x2 );
        regs.tailr.set(0xFFFF);
        regs.tapr.set((sysctl::get_system_frequency() / 16000) - 1 );
        regs.ctl.set(regs.ctl.get() | (1 << 0)); // TAEN
    }
}

impl hil::time::Time for AlarmTimer {
    type Frequency = hil::time::Freq16KHz;

    fn disable(&self) {
        self.disable_interrupts();
    }

    fn is_armed(&self) -> bool {
        let regs: &Registers = unsafe { &*self.registers };
        regs.imr.get() & (1 << 4) != 0 // TAMIM
    }
}

impl hil::time::Alarm for AlarmTimer {
    fn now(&self) -> u32 {
        let regs: &Registers = unsafe { &*self.registers };
        regs.tav.get()
    }

    fn set_alarm(&self, tics: u32) {
        let regs: &Registers = unsafe { &*self.registers };
        regs.tamatchr.set(tics & 0xFFFF);
        regs.imr.set(regs.imr.get() | (1 << 4)); // CC1IE
    }

    fn get_alarm(&self) -> u32 {
        let regs: &Registers = unsafe { &*self.registers };
        regs.tamatchr.get()
    }
}
